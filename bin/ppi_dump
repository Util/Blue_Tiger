#!/usr/bin/env perl
use strict;
use warnings;
use PPI;
use PPI::Dumper;
use Getopt::Long;

# This program is a development aid for Blue Tiger.
# It parses a piece of Perl code with PPI, then dumps the structure to STDOUT.

my $USAGE = <<'END_OF_USAGE';
Usage: ppi_dump [ -hw ] [ -noc ] [ -e 'command' ] [ programfile ]

    -e 'command'
        may be used to enter one line of program.  If −e is given, ppi_dump
        will not look for a filename in the argument list.  Multiple −e
        commands may be given to build up a multi‐line script.  Make sure
        to use semicolons where you would in a normal program.

    -w, --whitespace
        show whitespace tokens, which are normally suppressed.

    -noc, --nocontent
        suppress showing the content of each element.

    -h, --help
        prints this usage message and exits normally.
END_OF_USAGE

GetOptions(
    'c|content!'    => \( my $content    = 1 ),
    'w|whitespace'  => \( my $whitespace = 0 ),
    'h|help'        => \( my $help           ),
) or die $USAGE;

print $USAGE and exit(0) if $help;

die $USAGE if @ARGV != 1;
my ( $program_arg ) = @ARGV;

# The program can either take a filename, or quoted perl code.
# XXX Change to a -e option for quoted perl code, like for one-liners?
my $PPI_doc;
if ( $program_arg =~ m{\A\S+\z}msx and -s $program_arg ) {
    my $perl_filename = $program_arg;
    if ( not -e $perl_filename ) {
        die 'Your argument contained no whitespace, and so was interpreted'
          . " as a filename, but no file of the name '$perl_filename' exists!";
    }
    $PPI_doc = PPI::Document->new( $perl_filename );
}
else {
    my $perl_source_code = $program_arg;
    $PPI_doc = PPI::Document->new( \$perl_source_code );
}
die "Could not generate PPI from input '$program_arg'" if !defined $PPI_doc;


my $Dumper = PPI::Dumper->new(
    $PPI_doc,
    content    => $content,
    whitespace => $whitespace,
) or die;

$Dumper->print;
